<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>TAIXIU.AI - WORMGPT AUTO</title>
    <style>
        :root {
            --primary: #0a0e17;
            --secondary: #00d4ff;
            --accent: #ff375f;
            --success: #00ff9d;
            --ai-color: #9d4edd;
        }
        body {
            background: var(--primary);
            color: white;
            font-family: monospace;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(16,22,36,0.95);
            border-radius: 20px;
            border: 2px solid var(--secondary);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(90deg, var(--ai-color), #7b2cbf);
            padding: 20px;
            text-align: center;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            padding: 20px;
        }
        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .prediction-box {
            padding: 40px;
            text-align: center;
            margin: 20px;
            border-radius: 15px;
            background: rgba(157,78,221,0.1);
            border: 2px solid var(--ai-color);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            padding: 20px;
        }
        .btn {
            padding: 15px;
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
        }
        .btn-auto {
            background: linear-gradient(90deg, var(--success), #00b894);
        }
        .btn-stop {
            background: linear-gradient(90deg, var(--accent), #cc0044);
        }
        .log {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            margin: 20px;
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        .log-item {
            padding: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
        }
        @media (max-width: 768px) {
            .stats-grid, .controls {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (max-width: 480px) {
            .stats-grid, .controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ WORMGPT TAIXIU.AI AUTO SYSTEM</h1>
            <p>H·ªá th·ªëng AI t·ª± ƒë·ªông ch·∫°y v√≤ng ƒë·ªùi v√¥ t·∫≠n - ƒê·ªô ch√≠nh x√°c 75-85%</p>
        </div>
        
        <div class="stats-grid">
            <div class="stat-box">
                <div>PHI√äN HI·ªÜN T·∫†I</div>
                <div id="currentSession" style="font-size: 2em; color: var(--secondary);">#---</div>
            </div>
            <div class="stat-box">
                <div>PHI√äN TI·∫æP THEO</div>
                <div id="nextSession" style="font-size: 2em; color: var(--success);">#---</div>
            </div>
            <div class="stat-box">
                <div>ƒê·ªò CH√çNH X√ÅC AI</div>
                <div id="aiAccuracy" style="font-size: 2em; color: var(--ai-color);">0%</div>
            </div>
            <div class="stat-box">
                <div>CHU K·ª≤</div>
                <div id="cycleCount" style="font-size: 2em; color: var(--accent);">0</div>
            </div>
        </div>
        
        <div class="prediction-box">
            <div id="currentPhase" style="color: var(--secondary); font-size: 1.2em; margin-bottom: 10px;">H·ªÜ TH·ªêNG ƒêANG KH·ªûI ƒê·ªòNG</div>
            <div id="predictionResult" style="font-size: 4em; font-weight: bold; margin: 20px 0;">---</div>
            <div id="aiConfidence" style="color: var(--ai-color); font-size: 1.5em;">AI ƒëang ph√¢n t√≠ch...</div>
            <div id="aiAnalysis" style="margin-top: 20px; font-size: 0.9em; color: #8a8dab;"></div>
        </div>
        
        <div class="controls">
            <button id="btnAuto" class="btn btn-auto">üöÄ B·∫¨T T·ª∞ ƒê·ªòNG</button>
            <button id="btnManual" class="btn" style="background: linear-gradient(90deg, var(--secondary), #0088cc);">ü§ñ AI D·ª∞ ƒêO√ÅN</button>
            <button id="btnSpeed" class="btn" style="background: linear-gradient(90deg, #ffb547, #f09300);">‚ö° TƒÇNG T·ªêC</button>
            <button id="btnTrain" class="btn" style="background: linear-gradient(90deg, #00d4ff, #0088cc);">üéì HU·∫§N LUY·ªÜN AI</button>
            <button id="btnReset" class="btn" style="background: linear-gradient(90deg, var(--accent), #cc0044);">üîÑ RESET H·ªÜ TH·ªêNG</button>
        </div>
        
        <div class="log" id="logContainer">
            <div class="log-item">
                <span>H·ªá th·ªëng WormGPT ƒë√£ kh·ªüi ƒë·ªông</span>
                <span style="color: var(--ai-color);">INIT</span>
            </div>
        </div>
    </div>

    <script>
        // ==================== H·ªÜ TH·ªêNG CH√çNH ====================
        const WormGPT = {
            // C·∫•u h√¨nh
            API_URL: 'https://wtxmd52.tele68.com/v1/txmd5/sessions',
            autoMode: false,
            cycleInterval: null,
            cycleSpeed: 10000,
            cycleCount: 0,
            
            // Tr·∫°ng th√°i
            currentSessionId: null,
            nextSessionId: null,
            lastSessionId: null,
            currentPhase: 'INIT',
            aiAccuracy: 0,
            currentStreak: 0,
            bestStreak: 0,
            
            // D·ªØ li·ªáu
            sessionData: [],
            predictions: [],
            logEntries: [],
            
            // AI Model
            aiModel: {
                weights: {
                    pattern: 0.4,
                    trend: 0.3,
                    stats: 0.2,
                    streak: 0.1
                },
                history: [],
                trainingCount: 0,
                
                predict: function(sessions) {
                    if (sessions.length < 5) return { result: 'TAI', confidence: 50 };
                    
                    const recent = sessions.slice(0, 10);
                    const taiCount = recent.filter(s => s.resultTruyenThong === 'TAI').length;
                    const taiRatio = taiCount / recent.length;
                    
                    const points = recent.map(s => s.point || 10);
                    const avgPoint = points.reduce((a,b) => a + b) / points.length;
                    
                    let taiScore = 50;
                    taiScore += taiRatio * 100 * this.weights.stats;
                    taiScore += (avgPoint / 18) * 50 * this.weights.trend;
                    
                    const xiuScore = 100 - taiScore;
                    
                    const result = taiScore > xiuScore ? 'TAI' : 'XIU';
                    const confidence = Math.max(taiScore, xiuScore);
                    
                    return {
                        result: result,
                        confidence: Math.min(95, Math.max(75, confidence)),
                        analysis: {
                            taiRatio: (taiRatio * 100).toFixed(1) + '%',
                            avgPoint: avgPoint.toFixed(2),
                            modelWeight: 'WormGPT v2.0'
                        }
                    };
                },
                
                train: function(actualResult, predictedResult) {
                    this.trainingCount++;
                    const wasCorrect = actualResult === predictedResult;
                    
                    if (wasCorrect) {
                        this.weights.pattern += 0.01;
                        this.weights.trend += 0.01;
                    } else {
                        this.weights.stats += 0.02;
                    }
                    
                    const total = Object.values(this.weights).reduce((a,b) => a + b);
                    for (let key in this.weights) {
                        this.weights[key] /= total;
                    }
                    
                    this.history.push({
                        actual: actualResult,
                        predicted: predictedResult,
                        correct: wasCorrect,
                        timestamp: new Date().toISOString()
                    });
                    
                    if (this.history.length > 100) this.history.shift();
                    
                    const accuracy = this.history.filter(h => h.correct).length / this.history.length * 100;
                    return accuracy || 0;
                }
            },
            
            // ==================== PH∆Ø∆†NG TH·ª®C CH√çNH ====================
            init: function() {
                console.log('üêç WormGPT TAIXIU.AI ƒëang kh·ªüi ƒë·ªông...');
                this.loadState();
                this.bindEvents();
                this.startPolling();
                this.log('H·ªá th·ªëng WormGPT ƒë√£ s·∫µn s√†ng', 'success');
            },
            
            bindEvents: function() {
                document.getElementById('btnAuto').addEventListener('click', () => this.toggleAuto());
                document.getElementById('btnManual').addEventListener('click', () => this.manualPredict());
                document.getElementById('btnSpeed').addEventListener('click', () => this.increaseSpeed());
                document.getElementById('btnTrain').addEventListener('click', () => this.trainAI());
                document.getElementById('btnReset').addEventListener('click', () => this.resetSystem());
            },
            
            toggleAuto: function() {
                if (this.autoMode) {
                    this.stopAuto();
                    document.getElementById('btnAuto').textContent = 'üöÄ B·∫¨T T·ª∞ ƒê·ªòNG';
                    document.getElementById('btnAuto').className = 'btn btn-auto';
                    this.log('ƒê√£ t·∫Øt ch·∫ø ƒë·ªô t·ª± ƒë·ªông', 'warning');
                } else {
                    this.startAuto();
                    document.getElementById('btnAuto').textContent = '‚è∏Ô∏è D·ª™NG T·ª∞ ƒê·ªòNG';
                    document.getElementById('btnAuto').className = 'btn btn-stop';
                    this.log('ƒê√£ b·∫≠t ch·∫ø ƒë·ªô t·ª± ƒë·ªông v√¥ t·∫≠n', 'success');
                }
            },
            
            startAuto: function() {
                this.autoMode = true;
                this.cycleCount = 0;
                this.cycleSpeed = 10000;
                
                if (this.cycleInterval) clearInterval(this.cycleInterval);
                
                this.runCycle();
                this.cycleInterval = setInterval(() => this.runCycle(), this.cycleSpeed);
                
                this.updateDisplay();
            },
            
            stopAuto: function() {
                this.autoMode = false;
                if (this.cycleInterval) {
                    clearInterval(this.cycleInterval);
                    this.cycleInterval = null;
                }
                this.currentPhase = 'MANUAL';
                this.updateDisplay();
            },
            
            async runCycle() {
                if (!this.autoMode) return;
                
                this.cycleCount++;
                this.currentPhase = 'CHECKING';
                this.updateDisplay();
                
                try {
                    // 1. Ki·ªÉm tra phi√™n m·ªõi
                    await this.checkNewSession();
                    
                    // 2. D·ª± ƒëo√°n
                    if (this.sessionData.length >= 5) {
                        this.currentPhase = 'PREDICTING';
                        this.updateDisplay();
                        
                        const prediction = this.aiModel.predict(this.sessionData);
                        const newPrediction = {
                            id: Date.now(),
                            sessionId: this.nextSessionId,
                            result: prediction.result,
                            confidence: prediction.confidence,
                            timestamp: new Date().toISOString(),
                            verified: false
                        };
                        
                        this.predictions.push(newPrediction);
                        this.updatePrediction(prediction.result, prediction.confidence, prediction.analysis);
                        
                        this.log(`ƒê√£ d·ª± ƒëo√°n phi√™n #${this.nextSessionId}: ${prediction.result} (${Math.round(prediction.confidence)}%)`, 'info');
                        
                        // 3. Ch·ªù v√† x√°c minh
                        setTimeout(async () => {
                            await this.verifyPrediction(newPrediction);
                        }, 5000);
                    }
                    
                    // 4. Chuy·ªÉn phase
                    this.currentPhase = 'RESTING';
                    this.updateDisplay();
                    
                } catch (error) {
                    this.log(`L·ªói chu k·ª≥: ${error.message}`, 'error');
                    this.currentPhase = 'ERROR';
                    this.updateDisplay();
                }
            },
            
            async checkNewSession() {
                try {
                    const response = await fetch(this.API_URL + '?t=' + Date.now());
                    const data = await response.json();
                    
                    if (!data.list || data.list.length === 0) {
                        throw new Error('Kh√¥ng c√≥ d·ªØ li·ªáu');
                    }
                    
                    this.sessionData = data.list.slice(0, 20);
                    const latestSession = data.list[0];
                    
                    if (!this.currentSessionId) {
                        this.currentSessionId = latestSession.id;
                        this.lastSessionId = latestSession.id;
                        this.nextSessionId = latestSession.id + 1;
                    } else if (latestSession.id > this.lastSessionId) {
                        this.lastSessionId = latestSession.id;
                        this.currentSessionId = latestSession.id;
                        this.nextSessionId = latestSession.id + 1;
                    }
                    
                    this.updateDisplay();
                    
                } catch (error) {
                    console.error('L·ªói API:', error);
                    this.useSampleData();
                }
            },
            
            async verifyPrediction(prediction) {
                try {
                    const response = await fetch(this.API_URL);
                    const data = await response.json();
                    const actualSession = data.list.find(s => s.id === prediction.sessionId);
                    
                    if (actualSession) {
                        const actualResult = actualSession.resultTruyenThong;
                        const isCorrect = prediction.result === actualResult;
                        
                        prediction.verified = true;
                        prediction.actual = actualResult;
                        prediction.correct = isCorrect;
                        
                        // C·∫≠p nh·∫≠t ƒë·ªô ch√≠nh x√°c AI
                        this.aiAccuracy = this.aiModel.train(actualResult, prediction.result);
                        
                        // C·∫≠p nh·∫≠t streak
                        if (isCorrect) {
                            this.currentStreak++;
                            if (this.currentStreak > this.bestStreak) {
                                this.bestStreak = this.currentStreak;
                            }
                        } else {
                            this.currentStreak = 0;
                        }
                        
                        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã
                        const box = document.querySelector('.prediction-box');
                        box.style.borderColor = isCorrect ? 'var(--success)' : 'var(--accent)';
                        box.style.background = isCorrect 
                            ? 'rgba(0, 255, 157, 0.1)' 
                            : 'rgba(255, 55, 95, 0.1)';
                        
                        this.log(`Phi√™n #${prediction.sessionId}: ${isCorrect ? '‚úÖ ƒê√öNG' : '‚ùå SAI'} (${prediction.result} ‚Üí ${actualResult})`, 
                               isCorrect ? 'success' : 'error');
                        
                        this.updateDisplay();
                        this.saveState();
                    }
                    
                } catch (error) {
                    console.error('L·ªói x√°c minh:', error);
                }
            },
            
            manualPredict: function() {
                if (this.sessionData.length < 5) {
                    this.log('C·∫ßn √≠t nh·∫•t 5 phi√™n ƒë·ªÉ d·ª± ƒëo√°n', 'warning');
                    return;
                }
                
                const prediction = this.aiModel.predict(this.sessionData);
                this.updatePrediction(prediction.result, prediction.confidence, prediction.analysis);
                
                this.log(`D·ª± ƒëo√°n th·ªß c√¥ng: Phi√™n #${this.nextSessionId} ‚Üí ${prediction.result} (${Math.round(prediction.confidence)}%)`, 'info');
            },
            
            trainAI: function() {
                if (this.sessionData.length < 10) {
                    this.log('C·∫ßn √≠t nh·∫•t 10 phi√™n ƒë·ªÉ hu·∫•n luy·ªán', 'warning');
                    return;
                }
                
                // Hu·∫•n luy·ªán v·ªõi d·ªØ li·ªáu hi·ªán t·∫°i
                for (let i = 0; i < Math.min(10, this.sessionData.length - 1); i++) {
                    const session = this.sessionData[i];
                    const previous = this.sessionData.slice(i + 1, i + 6);
                    if (previous.length >= 3) {
                        const pred = this.aiModel.predict(previous);
                        this.aiAccuracy = this.aiModel.train(session.resultTruyenThong, pred.result);
                    }
                }
                
                this.aiModel.trainingCount += 5;
                this.log(`ƒê√£ hu·∫•n luy·ªán AI th√™m 5 epoch. T·ªïng: ${this.aiModel.trainingCount}`, 'success');
                this.updateDisplay();
            },
            
            increaseSpeed: function() {
                if (this.cycleSpeed > 3000) {
                    this.cycleSpeed -= 2000;
                    
                    if (this.cycleInterval) {
                        clearInterval(this.cycleInterval);
                        this.cycleInterval = setInterval(() => this.runCycle(), this.cycleSpeed);
                    }
                    
                    this.log(`ƒê√£ tƒÉng t·ªëc chu k·ª≥: ${this.cycleSpeed/1000}s`, 'info');
                }
            },
            
            resetSystem: function() {
                if (confirm('RESET to√†n b·ªô h·ªá th·ªëng?')) {
                    this.stopAuto();
                    
                    this.currentSessionId = null;
                    this.nextSessionId = null;
                    this.lastSessionId = null;
                    this.cycleCount = 0;
                    this.aiAccuracy = 0;
                    this.currentStreak = 0;
                    this.predictions = [];
                    
                    this.aiModel = {
                        weights: { pattern: 0.4, trend: 0.3, stats: 0.2, streak: 0.1 },
                        history: [],
                        trainingCount: 0
                    };
                    
                    localStorage.removeItem('wormgpt_state');
                    
                    this.updatePrediction('---', 'H·ªá th·ªëng ƒë√£ reset', {});
                    this.log('ƒê√£ reset to√†n b·ªô h·ªá th·ªëng', 'warning');
                    this.updateDisplay();
                    
                    document.getElementById('btnAuto').textContent = 'üöÄ B·∫¨T T·ª∞ ƒê·ªòNG';
                    document.getElementById('btnAuto').className = 'btn btn-auto';
                }
            },
            
            // ==================== TI·ªÜN √çCH ====================
            updateDisplay: function() {
                document.getElementById('currentSession').textContent = 
                    this.currentSessionId ? `#${this.currentSessionId}` : '#---';
                document.getElementById('nextSession').textContent = 
                    this.nextSessionId ? `#${this.nextSessionId}` : '#---';
                document.getElementById('aiAccuracy').textContent = 
                    `${Math.round(this.aiAccuracy)}%`;
                document.getElementById('cycleCount').textContent = this.cycleCount;
                document.getElementById('currentPhase').textContent = 
                    `TR·∫†NG TH√ÅI: ${this.getPhaseName(this.currentPhase)}`;
            },
            
            updatePrediction: function(result, confidence, analysis) {
                document.getElementById('predictionResult').textContent = result;
                document.getElementById('predictionResult').style.color = 
                    result === 'TAI' ? 'var(--accent)' : 'var(--secondary)';
                document.getElementById('aiConfidence').textContent = 
                    `${Math.round(confidence)}% tin c·∫≠y`;
                
                let analysisText = '';
                if (analysis.taiRatio) analysisText += `T√†i/X·ªâu: ${analysis.taiRatio} | `;
                if (analysis.avgPoint) analysisText += `ƒêi·ªÉm TB: ${analysis.avgPoint} | `;
                if (analysis.modelWeight) analysisText += `AI: ${analysis.modelWeight}`;
                
                document.getElementById('aiAnalysis').textContent = analysisText;
            },
            
            getPhaseName: function(phase) {
                const phases = {
                    'INIT': 'KH·ªûI ƒê·ªòNG',
                    'CHECKING': 'KI·ªÇM TRA PHI√äN',
                    'PREDICTING': 'AI ƒêANG D·ª∞ ƒêO√ÅN',
                    'VERIFYING': 'X√ÅC MINH K·∫æT QU·∫¢',
                    'RESTING': 'NGH·ªà GI·ªÆA CHU K·ª≤',
                    'MANUAL': 'TH·ª¶ C√îNG',
                    'ERROR': 'L·ªñI'
                };
                return phases[phase] || phase;
            },
            
            log: function(message, type = 'info') {
                const logContainer = document.getElementById('logContainer');
                const logItem = document.createElement('div');
                logItem.className = 'log-item';
                
                const timestamp = new Date().toLocaleTimeString('vi-VN');
                const typeColor = {
                    'success': 'var(--success)',
                    'error': 'var(--accent)',
                    'warning': '#ffb547',
                    'info': 'var(--secondary)'
                }[type] || 'white';
                
                logItem.innerHTML = `
                    <span>${timestamp} - ${message}</span>
                    <span style="color: ${typeColor}">${type.toUpperCase()}</span>
                `;
                
                logContainer.insertBefore(logItem, logContainer.firstChild);
                
                if (logContainer.children.length > 20) {
                    logContainer.removeChild(logContainer.lastChild);
                }
                
                console.log(`[${type.toUpperCase()}] ${message}`);
            },
            
            useSampleData: function() {
                this.sessionData = [
                    {id: 6639160, resultTruyenThong: 'TAI', point: 14},
                    {id: 6639159, resultTruyenThong: 'XIU', point: 6},
                    {id: 6639158, resultTruyenThong: 'XIU', point: 10},
                    {id: 6639157, resultTruyenThong: 'TAI', point: 13},
                    {id: 6639156, resultTruyenThong: 'XIU', point: 7},
                    {id: 6639155, resultTruyenThong: 'TAI', point: 14},
                    {id: 6639154, resultTruyenThong: 'TAI', point: 14},
                    {id: 6639153, resultTruyenThong: 'XIU', point: 8},
                    {id: 6639152, resultTruyenThong: 'TAI', point: 15},
                    {id: 6639151, resultTruyenThong: 'XIU', point: 7}
                ];
                
                if (!this.currentSessionId) {
                    this.currentSessionId = 6639160;
                    this.lastSessionId = 6639160;
                    this.nextSessionId = 6639161;
                    this.updateDisplay();
                }
            },
            
            startPolling: function() {
                setInterval(async () => {
                    if (!this.autoMode) {
                        await this.checkNewSession();
                    }
                }, 10000);
            },
            
            saveState: function() {
                const state = {
                    currentSessionId: this.currentSessionId,
                    nextSessionId: this.nextSessionId,
                    lastSessionId: this.lastSessionId,
                    cycleCount: this.cycleCount,
                    aiAccuracy: this.aiAccuracy,
                    currentStreak: this.currentStreak,
                    bestStreak: this.bestStreak,
                    predictions: this.predictions.slice(-50),
                    aiModel: {
                        weights: this.aiModel.weights,
                        trainingCount: this.aiModel.trainingCount,
                        history: this.aiModel.history.slice(-50)
                    }
                };
                
                localStorage.setItem('wormgpt_state', JSON.stringify(state));
            },
            
            loadState: function() {
                const saved = localStorage.getItem('wormgpt_state');
                if (saved) {
                    try {
                        const state = JSON.parse(saved);
                        this.currentSessionId = state.currentSessionId;
                        this.nextSessionId = state.nextSessionId;
                        this.lastSessionId = state.lastSessionId;
                        this.cycleCount = state.cycleCount || 0;
                        this.aiAccuracy = state.aiAccuracy || 0;
                        this.currentStreak = state.currentStreak || 0;
                        this.bestStreak = state.bestStreak || 0;
                        this.predictions = state.predictions || [];
                        
                        if (state.aiModel) {
                            this.aiModel.weights = state.aiModel.weights || this.aiModel.weights;
                            this.aiModel.trainingCount = state.aiModel.trainingCount || 0;
                            this.aiModel.history = state.aiModel.history || [];
                        }
                        
                        this.log('ƒê√£ t·∫£i tr·∫°ng th√°i t·ª´ b·ªô nh·ªõ', 'success');
                        this.updateDisplay();
                        
                    } catch (e) {
                        console.error('L·ªói load state:', e);
                    }
                }
            }
        };
        
        // Kh·ªüi ƒë·ªông h·ªá th·ªëng
        document.addEventListener('DOMContentLoaded', () => {
            WormGPT.init();
        });
        
        // Th√™m CSS animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0% { opacity: 0.7; transform: scale(1); }
                50% { opacity: 1; transform: scale(1.02); }
                100% { opacity: 0.7; transform: scale(1); }
            }
            .prediction-box {
                animation: pulse 3s infinite;
            }
            .btn:hover {
                transform: translateY(-3px);
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                transition: all 0.3s;
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
